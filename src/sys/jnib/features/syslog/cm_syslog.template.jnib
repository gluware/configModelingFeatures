// Copyright (C) 2017 Glue Networks - All Rights Reserved
// This feature package is provided as is with no implied warranties or fitness for a particular purpose.
// Glue Networks, Inc. will not provide maintenance, support, updates, enhancements or modifications.

featureParams : {

	// featureParams currently contains two fields: concept and portMap.
	//   • concept is that path to the featureConcept global. That's the CLI model for this syslog template feature.
	//   • portMap is the path to the abstraction map global. This is used to model all the interfaces involved in 
	//   the template in order to call/refer to them by name. That allows deploying the same feature across platform with a
	//   different port/interface layout. For instance, for a firewall using wan, lan and dmz as ports for the physical
	//   appliance vs port1, port2 and port3 for the virtual edition, the abstraction map can declare these three interfaces
	//   and calling them by name in the CLI under $context.intfs (for ex. $context.intfs.DATA or $context.intfs.ISP).

},

initFeature: function() {

	// TODO (optional): Add here the pre processing code for the $(feature) feature.
	// This function will be executed before the processFeature function will run. This function is useful when
	// conditional concept files need to be used. As a consequence, the concept file can be loaded dynamically. 
	// For instance, when vendor and/or hardware abstraction is required: 
	//   switch (node.vendor) {
	//     case "cisco":
	//       thisNib.featureParams.concept = "/org/instance/construct/global/featureConcept/qosFeatureConcept_for_Cisco.json"; 		
	//       break;
	//     case "juniper":
	//       thisNib.featureParams.concept = "/org/instance/construct/global/featureConcept/qosFeatureConcept_for_Juniper.json"; 		
	//       break;
	//   }

},

processFeature : function () {

	// If the form uses the advanced attribute, this formats the second half of the string for the logging host command cisco ios dependent
	var type = getKey(node);
	
	if (!util.isEmpty(thisNib.ref.syslog)) {
		if (thisNib.ref.syslog.mode == "advanced") {
			for(var i = 0; i < thisNib.ref.syslog.server.length; i++){
	
				var sessionId = thisNib.ref.syslog.server[i].sessionId;
				thisNib.ref.syslog.server[i].advanced = "transport " + thisNib.ref.syslog.server[i].protocol + " port " + thisNib.ref.syslog.server[i].port;
	
				if (!util.isEmpty(thisNib.ref.syslog.server[i].level)) {
					
					var logLevel = thisNib.ref.syslog.server[i].level;

					if (node.vendor === "checkpoint" || node.type === "arubaoscx") {
						log.debug("The syslog feature determined this device is " + node.vendor);
						switch (logLevel) {
							case "emergencies" :
								thisNib.ref.syslog.server[i].level = "emerg";
								break;
							case "alerts" :
								thisNib.ref.syslog.server[i].level = "alert";
								break;
							case "critical" :
								thisNib.ref.syslog.server[i].level = "crit";
								break;
							case "errors" :
								thisNib.ref.syslog.server[i].level = "err";
								break;
							case "warnings" :
								thisNib.ref.syslog.server[i].level = "warning";
								break;
							case "notifications" :
								thisNib.ref.syslog.server[i].level = "notice";
								break;
							case "informational" :
								thisNib.ref.syslog.server[i].level = "info";
								break;
							case "debugging" :
								thisNib.ref.syslog.server[i].level = "debug";
								break;
							default:
								thisNib.ref.syslog.server[i].level = "all";
						} 
					} else if (node.type === "nxos") {
						log.debug("The Syslog Feature determined this device is " + node.vendor);
						switch (logLevel) {
							case "emergencies" :
								thisNib.ref.syslog.server[i].level = "0";
								break;
							case "alerts" :
								thisNib.ref.syslog.server[i].level = "1";
								break;
							case "critical" :
								thisNib.ref.syslog.server[i].level = "2";
								break;
							case "errors" :
								thisNib.ref.syslog.server[i].level = "3";
								break;
							case "warnings" :
								thisNib.ref.syslog.server[i].level = "4";
								break;
							case "notifications" :
								thisNib.ref.syslog.server[i].level = "5";
								break;
							case "informational" :
								thisNib.ref.syslog.server[i].level = "6";
								break;
							case "debugging" :
								thisNib.ref.syslog.server[i].level = "7";
								break;
							default:
								thisNib.ref.syslog.server[i].level = "7";
						}
					}
				}

				
				if (sessionId != null) {
					if (sessionId == "string") {
						thisNib.ref.syslog.server[i].advanced += " session-id string " + thisNib.ref.syslog.server[i].name;
					} else {
						thisNib.ref.syslog.server[i].advanced += " session-id " + sessionId;
					}
				}
			}
		}
	
		// Switching logging level to text instead of severity level due to IOS displaying levels in text.
		// Otherwise, the compare engine will always identify a delta and try to update the config at every provisioning.
	
		if (!util.isEmpty(thisNib.ref.syslog.level)) {
	
			var logLevel = thisNib.ref.syslog.level;

			if (node.vendor === "checkpoint" || node.type === "arubaoscx") {
				log.debug("The syslog feature determined this device is " + node.vendor);
				switch (logLevel) {
					case "emergencies" :
						thisNib.ref.syslog.level = "emerg";
						break;
					case "alerts" :
						thisNib.ref.syslog.level = "alert";
						break;
					case "critical" :
						thisNib.ref.syslog.level = "crit";
						break;
					case "errors" :
						thisNib.ref.syslog.level = "err";
						break;
					case "warnings" :
						thisNib.ref.syslog.level = "warning";
						break;
					case "notifications" :
						thisNib.ref.syslog.level = "notice";
						break;
					case "informational" :
						thisNib.ref.syslog.level = "info";
						break;
					case "debugging" :
						thisNib.ref.syslog.level = "debug";
						break;
					default:
						thisNib.ref.syslog.level = "all";
				} 
			} else if (node.type === "nxos") {
				log.debug("The Syslog Feature determined this device is " + node.vendor);
				switch (logLevel) {
					case "emergencies" :
						thisNib.ref.syslog.level = "0";
						break;
					case "alerts" :
						thisNib.ref.syslog.level = "1";
						break;
					case "critical" :
						thisNib.ref.syslog.level = "2";
						break;
					case "errors" :
						thisNib.ref.syslog.level = "3";
						break;
					case "warnings" :
						thisNib.ref.syslog.level = "4";
						break;
					case "notifications" :
						thisNib.ref.syslog.level = "5";
						break;
					case "informational" :
						thisNib.ref.syslog.level = "6";
						break;
					case "debugging" :
						thisNib.ref.syslog.level = "7";
						break;
					default:
						thisNib.ref.syslog.level = "7";
				}
			}
		}
	
		// Pulls the interface name information out of the port map
	
		if (!util.isEmpty(thisNib.ref.syslog.srcInt)) {
			if (!util.isEmpty(thisNib.ref.portMap)) {
				if (thisNib.ref.portMap[getGlobalInstanceName(thisNib.ref.syslog.srcInt)]) {
					thisNib.ref.syslog.srcInt = thisNib.ref.portMap[getGlobalInstanceName(thisNib.ref.syslog.srcInt)].name;
				} else {
					abort("The source-interface (" + getGlobalInstanceName(thisNib.ref.syslog.srcInt) + ") selected in the Syslog Feature does NOT exist in " + node.name + "'s portMap.");
				}
			} else {
				log.warning("A portMap is NOT present on this device's Assembly. Therefore, it's unable to dynamically set the Syslog source-interface.")
			}
		} else {
			log.warning("A Source-interface is NOT selected in the Syslog Feature.");
		}
	}
	
},

postProcess : function () {

	// TODO (optional): Add here the post processing code for the $(feature) feature.
	// This function will be executed after the FSE has finished rendering all the objects in the node object store.
	// This is an optional feature that is useful if the feature required handling of additional commands once the CLI
	// configuration has been sent to the target node (for instance, enrolling a certificate once the trustpoint has
	// been configured). This method is optional.
	//
	// Quick reminder of the shell commands available:
	//   • send() is what is sending the CLI command to the node.
	//   • getSendResponseStr() is the method that gets the CLI response.
	//   • getSendResponseMatch() is the equivalent that is mapped to a regex match.
	//   • setResponseInactivityTimeout() defines the inactivity timer the engine will wait the node response.
	//   • registerResponseInactivity(<function>, args…) calls the <function> when the inactivity timer has been triggered.
	//   • registerConnectSuccess(<function>, args…) calls the <function> when the connection with the node is successful.

},

deleteNode: function() {

	// TODO (optional): Add here all the processing required when the node is being deleted such as cleaning up some data 
	// in the attached storage or similar. This method is optional.

},

unprovision: function() {

	// TODO (optional): Add here all the processing required when the feature is being removed from the node assembly.
	// If you want the feature to become unmanaged (in other words, you want the associated CLI to be kept in the node
	// but no longer handled by gluware, then remove the unprovision() call. However, if you want the feature to be
	// also removed from the target node, then this is why the unprovision() call has been designed for. 
	// Remember that the rendering is always called after the expert code and the FSE will look into the node object
	// store to see what objects needs to be rendered. If the object store is empty (because you don't do anything
	// in the unprovision() mathod, and because the FSE works with a declarative approach, all the objects following
	// the naming convention (and associated CLI commands) will be removed from the target node. 
	// This method is optional.

},

preview: function() {

	// TODO (optional): Add here all the processing required when you want to make visible an output when the preview action
	// is called. This method is optional.

	thisNib.run();

}
